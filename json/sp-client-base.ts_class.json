{
  "BasicHttpClient": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "BasicHttpClient implements a basic set of features for performing REST operations. \nThe subclass HttpClient extends this basic functionality with SharePoint-specific \nenhancements.",
    "properties": {
      "serviceScope": {
        "dataType": "ServiceScope",
        "accessModifier": "protected",
        "isOptional": false,
        "type": " ServiceScope",
        "isCollection": false,
        "descr": "Calls fetch(),but sets the method to 'POST'."
      }
    },
    "methods": {
      "constructor~42927": {
        "accessModifier": "public",
        "signature": "constructor(serviceScope: ServiceScope)",
        "isStatic": false,
        "isOptional": false,
        "descr": "",
        "genericType": null,
        "returnType": "ServiceScope",
        "returnDescr": null,
        "params": [
          {
            "name": "serviceScope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "fetch~83242": {
        "accessModifier": "public",
        "signature": "public fetch(url: string,options: IBasicHttpClientOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Performs a REST service call. Although the HttpClient subclass adds \nadditional enhancements, the parameters and semantics for BasicHttpClient.fetch() \nare essentially the same as the WHATWG API standard that is documented here: \nhttps:",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IBasicHttpClientOptions",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "fetchCore~16302": {
        "accessModifier": "protected",
        "signature": "protected fetchCore(request: Request): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Performs a REST service call. Although the HttpClient subclass adds \nadditional enhancements, the parameters and semantics for BasicHttpClient.fetch() \nare essentially the same as the WHATWG API standard that is documented here: \nhttps:",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "request",
            "dataType": "Request",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "get~65965": {
        "accessModifier": "public",
        "signature": "public get(url: string,options?: IBasicHttpClientOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Calls fetch(),but sets the method to 'GET'.",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IBasicHttpClientOptions",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "post~69124": {
        "accessModifier": "public",
        "signature": "public post(url: string,options: IBasicHttpClientOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Calls fetch(),but sets the method to 'POST'.",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IBasicHttpClientOptions",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "Compare": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": " \nThis class contains various comparison utilities. \n",
    "properties": {},
    "methods": {
      "shallowCompare~39803": {
        "accessModifier": "public",
        "signature": "public shallowCompare(objA: Object,objB: Object): boolean",
        "isStatic": true,
        "isOptional": false,
        "descr": "Performs shallow comparison between two objects to determine if they are equal. This method compares \nonly object types. \n",
        "genericType": null,
        "returnType": "boolean",
        "returnDescr": null,
        "params": [
          {
            "name": "objA",
            "dataType": "Object",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "objB",
            "dataType": "Object",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "CultureInfo": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class is primarily used with the PageContext class. It provides culture info \nfor the current user of the application.",
    "properties": {
      "currentCultureName": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "This string determines the language default format for dates,times,numbers,currency values, \nthe sorting order of text, casing conventions, and string comparisons. This property may have \nan empty string, but will never be undefined. \nExample: If the currentCultureName is \"en-au\" then the application could use this information \nto display the date as 1/8 instead of 8/1."
      },
      "currentUICultureName": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "This string determines the default user interface language. This used for localization and \ntranslation of text. This property may have an empty string, but will never be undefined. \nExample: If the currentUICultureName is \"es-mx\", then the application could use this \ninformation to translate the word \"hello\" to \"hola\"."
      }
    },
    "methods": {},
    "functions": {}
  },
  "Environment": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class contains contextual information about the enviroment that is hosting the framework and \nits components.",
    "properties": {
      "type": {
        "dataType": "EnvironmentType",
        "accessModifier": "public",
        "isOptional": false,
        "type": " EnvironmentType",
        "isCollection": false,
        "descr": "An enum that describes which type of enviroment the framework is running in."
      }
    },
    "methods": {},
    "functions": {}
  },
  "Guid": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class represents a globally unique identifier,as described by \nIETF RFC 4122. The input string is normalized and validated by the class \nconstructor, which provides important guarantees that simplify other code \nthat works with the GUID. This class also provides basic functionality \nfor generating a pseudo-random GUID (\"version 4\" UUID from the RFC); \nhowever, be aware that the uniqueness depends on the browser's \nMath.random() function and may be not be suitable for some applications. \n",
    "properties": {},
    "methods": {
      "equals~91036": {
        "accessModifier": "public",
        "signature": "public equals(guid: Guid): boolean",
        "isStatic": false,
        "isOptional": false,
        "descr": "represent the same value",
        "genericType": null,
        "returnType": "boolean",
        "returnDescr": null,
        "params": [
          {
            "name": "guid",
            "dataType": "Guid",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "isValid~79246": {
        "accessModifier": "public",
        "signature": "public isValid(guid: string): boolean",
        "isStatic": true,
        "isOptional": false,
        "descr": "Indicates whether a guid is valid (according to RFC4122). \n",
        "genericType": null,
        "returnType": "boolean",
        "returnDescr": null,
        "params": [
          {
            "name": "guid",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "constructorGuid~69818": {
        "accessModifier": "public",
        "signature": "public newGuid(randomProvider?: IRandomProvider): Guid",
        "isStatic": true,
        "isOptional": false,
        "descr": "Returns a new Guid instance with a pseudo-randomly generated Guid. \n",
        "genericType": null,
        "returnType": "Guid",
        "returnDescr": null,
        "params": [
          {
            "name": "randomProvider",
            "dataType": "IRandomProvider",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "toString~60006": {
        "accessModifier": "public",
        "signature": "public toString(): string",
        "isStatic": false,
        "isOptional": false,
        "descr": "Example: 'd5369f3b-bd7a-412a-9c0f-7f0650bb5489'",
        "genericType": null,
        "returnType": "string",
        "returnDescr": null,
        "params": []
      },
      "tryParse~41276": {
        "accessModifier": "public",
        "signature": "public tryParse(guid: string): Guid",
        "isStatic": true,
        "isOptional": false,
        "descr": "Trys to construct a new Guid instance using guid string. The guid argument \nis normalized and validated. If the argument is not a valid \"version 4\" UUID from \nRFC 4122, tryParse will return undefined. \n",
        "genericType": null,
        "returnType": "Guid",
        "returnDescr": null,
        "params": [
          {
            "name": "guid",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "HttpClient": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "HttpClient is used to perform REST calls against SharePoint. It adds default \nheaders, manages the digest needed for writes, and collects telemetry that \nhelps the service to monitor the performance of an application. \n \nFor communicating with non-SharePoint services, use the BasicHttpClient \nclass instead.",
    "properties": {},
    "methods": {
      "constructor~86297": {
        "accessModifier": "public",
        "signature": "constructor(serviceScope: ServiceScope)",
        "isStatic": false,
        "isOptional": false,
        "descr": "",
        "genericType": null,
        "returnType": "ServiceScope",
        "returnDescr": null,
        "params": [
          {
            "name": "serviceScope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "beginBatch~86648": {
        "accessModifier": "public",
        "signature": "public beginBatch(batchOptions?: IODataBatchOptions): ODataBatch",
        "isStatic": false,
        "isOptional": false,
        "descr": "Begins an ODATA batch,which allows multiple REST queries to be bundled into \na single web request.",
        "genericType": null,
        "returnType": "ODataBatch",
        "returnDescr": null,
        "params": [
          {
            "name": "batchOptions",
            "dataType": "IODataBatchOptions",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "fetch~50255": {
        "accessModifier": "public",
        "signature": "public fetch(url: string,options: IHttpClientOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Generally,the parameters and semantics for HttpClient.fetch() are essentially \nthe same as the WHATWG API standard that is documented here: \nhttps: \n \nThe HttpClient subclass adds some additional behaviors that are convenient when \nworking with SharePoint ODATA API's (which can be avoided by using \nBasicHttpClient instead): \n- Default \"Accept\" and \"Content-Type\" headers are added if not explicitly specified. \n- For write operations, an \"X-RequestDigest\" header is automatically added \n- The request digest token is automatically fetched and stored in a cache, with \nsupport for preloading \n \nFor a write operation, HttpClient will automatically add the \"X-RequestDigest\" \nheader, which may need to be obtained by issuing a seperate request such as \n\"https: \nSPWeb URL can be guessed by looking for a reserved URL segment such as \"_api\" \nin the original URL passed to fetch(); if not, use IHttpClientOptions.webUrl \nto specify it explicitly. \n",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IHttpClientOptions",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "get~39010": {
        "accessModifier": "public",
        "signature": "public get(url: string,options?: IHttpClientOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Calls fetch(),but sets the method to 'GET'.",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IHttpClientOptions",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "getWebUrlFromRequestUrl~14241": {
        "accessModifier": "public",
        "signature": "public getWebUrlFromRequestUrl(requestUrl: string): string",
        "isStatic": true,
        "isOptional": false,
        "descr": "This uses a heuristic to guess the SPWeb URL associated with the provided \nREST URL. This is necessary for operations such as the X-RequestDigest \nand ODATA batching, which require POSTing to a separate REST endpoint \nin order to complete a request. \nFor excample, if the requestUrl is \"/sites/site/web/_api/service\", \nthe returned URL would be \"/sites/site/web\". Or if the requestUrl \nis \"http: \n\"http:",
        "genericType": null,
        "returnType": "string",
        "returnDescr": null,
        "params": [
          {
            "name": "requestUrl",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "post~61649": {
        "accessModifier": "public",
        "signature": "public post(url: string,options: IHttpClientOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Calls fetch(),but sets the method to 'POST'.",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IHttpClientOptions",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "Log": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "The Log class provides methods for logging messages at different levels (verbose, \ninfo, warning, error) and with context information. Context information helps identify \nwhich component generated the messages and makes the messages useful and filterable. \n",
    "properties": {},
    "methods": {
      "error~49719": {
        "accessModifier": "public",
        "signature": "public error(source: string,error: Error,scope?: ServiceScope): void",
        "isStatic": true,
        "isOptional": false,
        "descr": "The source provides context information for the logged error. \nIf the source's length is more than 20, only the first 20 characters are kept.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "source",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "error",
            "dataType": "Error",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "scope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "info~70357": {
        "accessModifier": "public",
        "signature": "public info(source: string,message: string,scope?: ServiceScope): void",
        "isStatic": true,
        "isOptional": false,
        "descr": "more context information (e.g.,web part information) to the logged message.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "source",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "message",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "scope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "verbose~21286": {
        "accessModifier": "public",
        "signature": "public verbose(source: string,message: string,scope?: ServiceScope): void",
        "isStatic": true,
        "isOptional": false,
        "descr": "more context information (e.g.,web part information) to the logged message.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "source",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "message",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "scope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "warn~85083": {
        "accessModifier": "public",
        "signature": "public warn(source: string,message: string,scope?: ServiceScope): void",
        "isStatic": true,
        "isOptional": false,
        "descr": "more context information (e.g.,web part information) to the logged message.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "source",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "message",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "scope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": true
          }
        ]
      }
    },
    "functions": {}
  },
  "ODataBatch": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "The ODataBatch class accumulates a number of REST service calls and \ntransmits them as a single ODATA batch. This protocol is documented here: \nhttp: \n \nThe usage is to call ODataBatch.fetch() to queue each individual request, \nand then call ODataBatch.execute() to execute the batch operation. \nThe execute() method returns a promise that resolves when the real REST \ncall has completed. Each call to fetch() also returns a promise that will \nresolve with a Response object for that particular request. \n",
    "properties": {},
    "methods": {
      "constructor~33852": {
        "accessModifier": "public",
        "signature": "public constructor(serviceScope: ServiceScope,batchOptions?: IODataBatchOptions)",
        "isStatic": false,
        "isOptional": false,
        "descr": "",
        "genericType": null,
        "returnType": "IODataBatchOptions",
        "returnDescr": null,
        "params": [
          {
            "name": "serviceScope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "batchOptions",
            "dataType": "IODataBatchOptions",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "execute~28301": {
        "accessModifier": "public",
        "signature": "public execute(): Promise<ODataBatch>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Executes the batched queries that were queued using ODataBatch.fetch().",
        "genericType": null,
        "returnType": "Promise<ODataBatch>",
        "returnDescr": null,
        "params": []
      },
      "fetch~98350": {
        "accessModifier": "public",
        "signature": "public fetch(url: string,options?: IODataBatchRequestOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Queues a new request,and returns a promise that can be used to access \nthe server response (after execute() has completed). The parameters for \nthis function are basically the same as the WHATWG API standard documented here: \nhttps: \n \nHowever, be aware that certain REST headers are ignored or not allowed inside \na batch. See the ODATA documentation for details. \n \nWhen execute() is called, it will POST to a URL such as \n\"http: \nguess the appropriate SPWeb URL by looking for a reserved URL segment such as \"_api\" \nin the first URL passed to fetch(). If not, use IODataBatchOptions.webUrl to specify it \nexplicitly. \n",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IODataBatchRequestOptions",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "get~25769": {
        "accessModifier": "public",
        "signature": "public get(url: string,options?: IODataBatchRequestOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Calls fetch(),but sets the method to 'GET'.",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IODataBatchRequestOptions",
            "descr": "",
            "isOptional": true
          }
        ]
      },
      "post~72045": {
        "accessModifier": "public",
        "signature": "public post(url: string,options: IODataBatchRequestOptions): Promise<Response>",
        "isStatic": false,
        "isOptional": false,
        "descr": "Calls fetch(),but sets the method to 'POST'.",
        "genericType": null,
        "returnType": "Promise<Response>",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "options",
            "dataType": "IODataBatchRequestOptions",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "PageContext": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "The page context provides standard definitions for common SharePoint objects \nthat need to be shared between the client-side application, web parts, and other \ncomponents. Typically the data is fetched via REST queries when navigating to a \nnew page, but it can also be preloaded by the web server, or filled from a custom \napplication cache.",
    "properties": {
      "cultureInfo": {
        "dataType": "CultureInfo",
        "accessModifier": "public",
        "isOptional": false,
        "type": " CultureInfo",
        "isCollection": false,
        "descr": "This class is primarily used with the PageContext class. It provides culture info \nfor the current user of the application."
      },
      "isInitialized": {
        "dataType": "boolean",
        "accessModifier": "public",
        "isOptional": false,
        "type": " boolean",
        "isCollection": false,
        "descr": "Returns whether the PageContext has been initialized."
      },
      "site": {
        "dataType": "SPSite",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPSite",
        "isCollection": false,
        "descr": "Contextual information for the SharePoint site collection (\"site\") that is hosting the page. \nThe site object will be defined if the PageContext was initialized."
      },
      "user": {
        "dataType": "SPUser",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPUser",
        "isCollection": false,
        "descr": "This class is primarily used with the PageContext class. It provides contextual information \nfor the SharePoint user that is accessing the page."
      },
      "web": {
        "dataType": "SPWeb",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPWeb",
        "isCollection": false,
        "descr": "Contextual information for the SharePoint site (\"web\") that is hosting the page. The web object \nwill be defined if the PageContext was initialized."
      }
    },
    "methods": {
      "constructor~33759": {
        "accessModifier": "public",
        "signature": "constructor(serviceScope: ServiceScope)",
        "isStatic": false,
        "isOptional": false,
        "descr": "",
        "genericType": null,
        "returnType": "ServiceScope",
        "returnDescr": null,
        "params": [
          {
            "name": "serviceScope",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "ServiceKey": {
    "implementsExtendsName": null,
    "genericType": "T",
    "descr": "The ServiceKey is a lookup key that is used when calling ServiceScope.consume() \nto fetch a dependency. The key also defines a default implementation of the \ndependency, which will be autocreated by the root scope if the dependency is not found. \nProviding a default implementation ensures that new dependencies can be safely \nintroduced without inadvertently breaking components that are loaded by an older host \n(that does not provide the new dependency).",
    "properties": {
      "create": {
        "dataType": "string,",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string,",
        "isCollection": false,
        "descr": "your application."
      },
      "defaultCreator": {
        "dataType": "ServiceCreator<T>",
        "accessModifier": "public",
        "isOptional": false,
        "type": " ServiceCreator<T>",
        "isCollection": false,
        "descr": "your application."
      },
      "id": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "your application."
      },
      "name": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "your application."
      }
    },
    "methods": {
      "constructor~93886": {
        "accessModifier": "public",
        "signature": "constructor(id: string,name: string,defaultCreator: ServiceCreator<T>)",
        "isStatic": false,
        "isOptional": false,
        "descr": "PRIVATE - Do not call this from your own code.",
        "genericType": null,
        "returnType": "ServiceCreator<T>",
        "returnDescr": null,
        "params": [
          {
            "name": "id",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "name",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "defaultCreator",
            "dataType": "ServiceCreator<T>",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "createCustom<T>~94115": {
        "accessModifier": "public",
        "signature": "public createCustom < T >(name: string,defaultCreator: ServiceCreator<T>): ServiceKey<T>",
        "isStatic": true,
        "isOptional": false,
        "descr": "your application.",
        "genericType": "T",
        "returnType": "ServiceKey<T>",
        "returnDescr": null,
        "params": [
          {
            "name": "name",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "defaultCreator",
            "dataType": "ServiceCreator<T>",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "ServiceScope": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "ServiceScope provides a formalized way for components to register and consume dependencies \n(\"services\"), and to enable different implementations to be registered in different scopes. \nThis improves modularity by decoupling components from their dependencies in an extensible way. \n \nFor example, suppose that various components need access to an IPageManager instance. We could \nsimply make the PageManager a singleton (i.e. global variable), but this will not work e.g. if \nwe need to create a pop-up dialog that requires a second PageManager instance. A better solution \nwould be to add the PageManager as a constructor parameter for each component that requires it, \nhowever then we immediately face the problem that any code that calls these constructors \nalso needs a PageManager parameter. In an application with many such dependencies, business \nlogic that ties together many subsystems would eventually pick up a constructor parameter \nfor every possible dependency, which is unwieldy. A natural solution would be to move all the \ndependencies into a class with name like \"ApplicationContext\", and then pass this around as our \nconstructor parameter. This enables the PageManager to be passed to classes that need it \nwithout cluttering the intermediary classes that don't. However, it still has a design problem \nthat \"ApplicationContext\" has hard-coded dependencies on many unrelated things. A more flexible \napproach is to make it a dictionary that can look up items for consumers/providers who know the \nright lookup key (i.e. ServiceKey). This is the popular \"service locator\" design pattern, \nfamiliar from the SPContext API in classic SharePoint. \n \nServiceScope takes this idea a step further in two important ways: First, it provides a scoping \nmechanism so that e.g. if we had two different pages, they could each consume a unique PageManager \ninstance while still sharing other common dependencies. Secondly, it allows for a ServiceKey \nto provide a default implementation of the dependency. This is important for API stability in \nour modular client-side environment: For example, suppose that version 2.0 of our application \nintroduced a new IDiagnosticTracing interface that a version 2.0 component will expect to consume. \nIf the version 2.0 component gets loaded by an older 1.0 application, it would fail. We could \nfix this by requiring each consumer to check for any missing dependencies and handle that case, \nbut it would require a lot of checks. A better solution is to ensure that a default implementation \nalways exists, perhaps just a trivial behavior, so that components don't have to worry about it. \n \nUsage: ServiceScope instances are created by calling either ServiceScope.startNewRoot() or \nServiceScope.startNewChild(). They are initially in an \"unfinished\" state, during which provide() \ncan be called to register service keys, but consume() is forbidden. After ServiceScope.finish() \nis called, consume() is allowed and provide() is now forbidden. These semantics ensure that \nServiceScope.consume() always returns the same result for the same key, and does not depend on \norder of initialization. It also allows us to support circular dependencies without worrying \nabout infinite loops, even when working with external components that were implemented by \nthird parties. To avoid mistakes, it's best to always call consume() inside a callback from \nserviceScope.whenFinished().",
    "properties": {
      "createAndProvide": {
        "dataType": "ServiceKey<T>,",
        "accessModifier": "public",
        "isOptional": false,
        "type": " ServiceKey<T>,",
        "isCollection": false,
        "descr": "This is a shorthand function that its equivalent to constructing a new instance of the \nsimpleServiceClass, then registering it by calling ServiceScope.provide()."
      }
    },
    "methods": {
      "constructor~10027": {
        "accessModifier": "public",
        "signature": "constructor(parent: ServiceScope)",
        "isStatic": false,
        "isOptional": false,
        "descr": "PRIVATE CONSTRUCTOR - DO NOT CALL THIS FROM YOUR OWN CODE.",
        "genericType": null,
        "returnType": "ServiceScope",
        "returnDescr": null,
        "params": [
          {
            "name": "parent",
            "dataType": "ServiceScope",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "consume<T>~41915": {
        "accessModifier": "public",
        "signature": "public consume < T >(serviceKey: ServiceKey<T>): T",
        "isStatic": false,
        "isOptional": false,
        "descr": "Components should call this function to \"consume\" a dependency,i.e. look up the serviceKey \nand return the registered service instance. If the instance cannot be found, then a default \ninstance will be autocreated and registered with the root ServiceScope.",
        "genericType": "T",
        "returnType": "T",
        "returnDescr": null,
        "params": [
          {
            "name": "serviceKey",
            "dataType": "ServiceKey<T>",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "createDefaultAndProvide<T>~71511": {
        "accessModifier": "public",
        "signature": "public createDefaultAndProvide < T >(serviceKey: ServiceKey<T>): T",
        "isStatic": false,
        "isOptional": false,
        "descr": "This is a shorthand function that constructs the default implementation of the specified \nserviceKey, and then registers it by calling ServiceScope.provide().",
        "genericType": "T",
        "returnType": "T",
        "returnDescr": null,
        "params": [
          {
            "name": "serviceKey",
            "dataType": "ServiceKey<T>",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "finish~82543": {
        "accessModifier": "public",
        "signature": "public finish(): void",
        "isStatic": false,
        "isOptional": false,
        "descr": "When a ServiceScope is first started,it is in an \"unfinished\" state where provide() is \nallowed but consume() is not allowed. After calling finish(), then consume() is allowed \nbut provide() is not allowed. This formalism completely eliminates a number of tricky bugs \nsuch as: Scope2 is a child of Scope1, and Scope1 provides instance A1 of interface A; \nif someone consumes A1 from Scope2 (via inheritance) before Scope2.provide() is called \nwith A2, then a subsequent call to Scope2.consume() might return a different result than \nthe previous call, which would be very confusing for developers.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": []
      },
      "getParent~87977": {
        "accessModifier": "public",
        "signature": "public getParent(): ServiceScope",
        "isStatic": false,
        "isOptional": false,
        "descr": "Returns the parent of the current ServiceScope,or undefined if this is a root scope.",
        "genericType": null,
        "returnType": "ServiceScope",
        "returnDescr": null,
        "params": []
      },
      "provide<T>~13992": {
        "accessModifier": "public",
        "signature": "public provide < T >(serviceKey: ServiceKey<T>,service: T): T",
        "isStatic": false,
        "isOptional": false,
        "descr": "ServiceScope.provide() is used to register an implemententation of the given serviceKey \nfor the current scope. It may only be used when the ServiceScope is in an \"unfinished\" \nstate, i.e. before finish() has been called.",
        "genericType": "T",
        "returnType": "T",
        "returnDescr": null,
        "params": [
          {
            "name": "serviceKey",
            "dataType": "ServiceKey<T>",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "service",
            "dataType": "T",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "startNewChild~78628": {
        "accessModifier": "public",
        "signature": "public startNewChild(): ServiceScope",
        "isStatic": false,
        "isOptional": false,
        "descr": "Constructs a new ServiceScope that is a child of the current scope. For any keys \nthat are not explicitly provided by the child scope, the parent hierarchy will be \nconsulted.",
        "genericType": null,
        "returnType": "ServiceScope",
        "returnDescr": null,
        "params": []
      },
      "startNewRoot~32051": {
        "accessModifier": "public",
        "signature": "public startNewRoot(): ServiceScope",
        "isStatic": true,
        "isOptional": false,
        "descr": "Create a new root-level ServiceScope. Only root-level scopes have the ability to autocreate \ndefault implementations of ServiceKeys.",
        "genericType": null,
        "returnType": "ServiceScope",
        "returnDescr": null,
        "params": []
      },
      "whenFinished~94089": {
        "accessModifier": "public",
        "signature": "public whenFinished(callback: () => void): void",
        "isStatic": false,
        "isOptional": false,
        "descr": "It is an error to call ServiceScope.consume() before finish() has been called. \nThe most reliable way to protect your component against this error is to perform the \nconsume() calls inside a whenFinished() callback. If the service scope is already \nfinished, then the callback will be executed immediately; otherwise, it will be executed \nlater when the scope is finished.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "callback",
            "dataType": "(",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "SPPermission": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class can be used to determine if the current user has a requested set of permissions. \nSpecifies the built-in permissions available in SharePoint Foundation \nDerived from OneDriveWeb/ODBNext/odsp-shared \nhttps:",
    "properties": {
      "addAndCustomizePages": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Add,change,or delete HTML pages or web part Pages,and edit the Web site using a SharePoint \nFoundationâ€“compatible editor."
      },
      "addDelPrivateWebParts": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Add or remove personal web parts on a web part Page."
      },
      "addListItems": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Add items to lists,add documents to document libraries,and add Web discussion comments."
      },
      "applyStyleSheets": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Apply a style sheet (.css file) to the Web site."
      },
      "applyThemeAndBorder": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Apply a theme or borders to the entire Web site."
      },
      "approveItems": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Approve a minor version of a list item or document."
      },
      "browseDirectories": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Enumerate files and folders in a Web site using Microsoft Office SharePoint Designer 2007 and WebDAV interfaces."
      },
      "browserUserInfo": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View information about users of the Web site."
      },
      "cancelCheckout": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Discard or check in a document which is checked out to another user."
      },
      "createAlerts": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Create e-mail alerts."
      },
      "createGroups": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Create a group of users that can be used anywhere within the site collection."
      },
      "createSSCSite": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Create a Web site using Self-Service Site Creation."
      },
      "deleteListItems": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Delete items from a list,documents from a document library,and Web discussion comments in documents."
      },
      "deleteVersions": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Delete past versions of a list item or document."
      },
      "editListItems": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Edit items in lists,edit documents in document libraries,edit Web discussion comments in documents, \nand customize web part Pages in document libraries."
      },
      "editMyUserInfo": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Allows a user to change his or her user information,such as adding a picture."
      },
      "emptyMask": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Has no permissions on the Web site. Not available through the user interface."
      },
      "enumeratePermissions": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Enumerate permissions on the Web site,list,folder,document,or list item."
      },
      "fullMask": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Has all permissions on the Web site. Not available through the user interface."
      },
      "layoutsPage": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View the layouts page?"
      },
      "manageAlerts": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Manage alerts for all users of the Web site."
      },
      "manageLists": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Create and delete lists,add or remove columns in a list,and add or remove public views of a list."
      },
      "managePermissions": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Create and change permission levels on the Web site and assign permissions to users and groups."
      },
      "managePersonalViews": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Create,change,and delete personal views of lists."
      },
      "manageSubwebs": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Create subsites such as team sites,Meeting Workspace sites,and Document Workspace sites."
      },
      "manageWeb": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Grant the ability to perform all administration tasks for the Web site as well as manage content. \nActivate, deactivate,or edit properties of Web site scoped Features through the object model or \nthrough the user interface (UI). When grantedon the root Web site of a site collection, activate, \ndeactivate, or edit properties of site collection scoped Features through the object model. To \nbrowse to the Site Collection Features page and activate or deactivate site collection scoped \nFeatures through the UI, you must be a site collection administrator."
      },
      "open": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Allow users to open a Web site,list,or folder to access items inside that container."
      },
      "openItems": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View the source of documents with server-side file handlers."
      },
      "updatePersonalWebParts": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Update web parts to display personalized information."
      },
      "useClientIntegration": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Use features that launch client applications otherwise,users must work on documents locally and upload changes."
      },
      "useRemoteAPIs": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "Use SOAP,WebDAV,or Microsoft Office SharePoint Designer 2007 interfaces to access the Web site."
      },
      "value": {
        "dataType": "IODataBasePermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " IODataBasePermission",
        "isCollection": false,
        "descr": "Returns the value of this SPPermission object"
      },
      "viewFormPages": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View forms,views,and application pages,and enumerate lists."
      },
      "viewListItems": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View items in lists,documents in document libraries,and view Web discussion comments."
      },
      "viewPages": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View pages in a Web site."
      },
      "viewUsageData": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View reports on Web site usage."
      },
      "viewVersions": {
        "dataType": "SPPermission",
        "accessModifier": "public",
        "isOptional": false,
        "type": " SPPermission",
        "isCollection": false,
        "descr": "View past versions of a list item or document."
      }
    },
    "methods": {
      "constructor~15461": {
        "accessModifier": "public",
        "signature": "constructor(value: IODataBasePermission)",
        "isStatic": false,
        "isOptional": false,
        "descr": "",
        "genericType": null,
        "returnType": "IODataBasePermission",
        "returnDescr": null,
        "params": [
          {
            "name": "value",
            "dataType": "IODataBasePermission",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "hasAllPermissions~49313": {
        "accessModifier": "public",
        "signature": "public hasAllPermissions(...requestedPerms: SPPermission[]): boolean",
        "isStatic": false,
        "isOptional": false,
        "descr": "Function for determining if a given permission mask has all of the requested permissions.",
        "genericType": null,
        "returnType": "boolean",
        "returnDescr": null,
        "params": [
          {
            "name": "...requestedPerms",
            "dataType": "SPPermission[]",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "hasAnyPermissions~82211": {
        "accessModifier": "public",
        "signature": "public hasAnyPermissions(...requestedPerms: SPPermission[]): boolean",
        "isStatic": false,
        "isOptional": false,
        "descr": "Function for determining if a given permission mask has any of the requested permissions.",
        "genericType": null,
        "returnType": "boolean",
        "returnDescr": null,
        "params": [
          {
            "name": "...requestedPerms",
            "dataType": "SPPermission[]",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "hasPermission~80265": {
        "accessModifier": "public",
        "signature": "public hasPermission(requestedPerm: SPPermission): boolean",
        "isStatic": false,
        "isOptional": false,
        "descr": "Function for checking if a given permission mask has the requested permission.",
        "genericType": null,
        "returnType": "boolean",
        "returnDescr": null,
        "params": [
          {
            "name": "requestedPerm",
            "dataType": "SPPermission",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "SPSite": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class is primarily used with the PageContext class. It provides contextual \ninformation for the SharePoint site collection (\"site\") that hosts the page. \n",
    "properties": {
      "id": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "The GUID that identifies the SPSite on the server."
      }
    },
    "methods": {},
    "functions": {}
  },
  "SPUser": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class is primarily used with the PageContext class. It provides contextual information \nfor the SharePoint user that is accessing the page. \n",
    "properties": {
      "displayName": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "The display name for the current user. \nExample: \"John Doe\""
      },
      "loginName": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "The login name for specified user. \nExample: \"example@microsoft.com\""
      }
    },
    "methods": {},
    "functions": {}
  },
  "SPWeb": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class is primarily used with the PageContext class. It provides contextual \ninformation for the SharePoint site (\"web\") that hosts the page.",
    "properties": {
      "absoluteUrl": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "Returns the absolute URL for this SPWeb. \nExample: \"https:"
      },
      "id": {
        "dataType": "Guid",
        "accessModifier": "public",
        "isOptional": false,
        "type": " Guid",
        "isCollection": false,
        "descr": "The GUID that identifies the SPWeb on the server or undefined if the Guid string \nvalue is invalid."
      },
      "serverRelativeUrl": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "Returns the server-relative URL for this SPWeb. \nExample: \"/sites/PubSite/SubWeb\""
      },
      "title": {
        "dataType": "string",
        "accessModifier": "public",
        "isOptional": false,
        "type": " string",
        "isCollection": false,
        "descr": "Returns the title of the SharePoint site."
      }
    },
    "methods": {},
    "functions": {}
  },
  "UrlQueryParameterCollection": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "Class for storing and retrieving query parameters. \nThe URL can be server-relative and it will parse empty/null strings. \nThe query parameters must start with ? to indicate the first query parameter and \nuse & for all subsequent parameters. The class also supports fragments. \nEdge cases behavior: \nEmpty value (www.example.com/?test=) stores key and empty value \nNo equals in queryParam (www.example.com/?test) stores key and undefined value \nEmpty queryParam (www.example.com/?&debug=on) stores undefined key and value \nQuery param with only equals (www.example.com/?=&debug=on stores empty string key and value",
    "properties": {},
    "methods": {
      "constructor~55835": {
        "accessModifier": "public",
        "signature": "constructor(url: string)",
        "isStatic": false,
        "isOptional": false,
        "descr": "",
        "genericType": null,
        "returnType": "string",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "getValue~69182": {
        "accessModifier": "public",
        "signature": "public getValue(param: string): string",
        "isStatic": false,
        "isOptional": false,
        "descr": "Returns the value of the first matching query parameter or undefined if the key doesn't exist. \nExamples: this._queryParameterList = [ \n{key: TEST, value: done}, \n{key: DEBUG, value: false}, \n{key: TEST, value: notdone}] \ngetValue('TEST') ---> 'done' \ngetValue('debug') ---> 'false' \ngetValue('lost') ---> undefined",
        "genericType": null,
        "returnType": "string",
        "returnDescr": null,
        "params": [
          {
            "name": "param",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "getValues~86840": {
        "accessModifier": "public",
        "signature": "public getValues(param: string): string[]",
        "isStatic": false,
        "isOptional": false,
        "descr": "Returns the values of all of the matching query parameters or undefined if the key doesn't exist. \nExamples: this._queryParameterList = [ \n{key: TEST, value: done}, \n{key: DEBUG, value: false}, \n{key: TEST, value: notdone}] \ngetValues('TEST') ---> ['done', 'notdone'] \ngetValues('debug') ---> ['false'] \ngetValues('lost') ---> undefined",
        "genericType": null,
        "returnType": "string[]",
        "returnDescr": null,
        "params": [
          {
            "name": "param",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "UrlUtilities": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "Common helper functions for working with URLs. These utilities are intended to be simple, \nsmall, and extremely common. Do not add advanced parsing logic to this file.",
    "properties": {},
    "methods": {
      "convertToODataStringLiteral~18495": {
        "accessModifier": "public",
        "signature": "public convertToODataStringLiteral(value: string): string",
        "isStatic": true,
        "isOptional": false,
        "descr": "Converts a variable to an OData string literal and escapes apostrophes. \nOData specification: \nhttps: \nbrowse/wsvn/odata/trunk/spec/ABNF/odata-abnf-construction-rules.txt \nSQUOTE-in-string = SQUOTE SQUOTE ; two consecutive single quotes represent one within a string literal \nExamples: \nconvertToODataStringLiteral(\"example's list\") ---> \"'example''s list'\" \nconvertToODataStringLiteral(\"example list\") ---> \"'example list'\" \nconvertToODataStringLiteral(\"'example list'\") ---> \"'''example list'''\"",
        "genericType": null,
        "returnType": "string",
        "returnDescr": null,
        "params": [
          {
            "name": "value",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "removeEndSlash~70016": {
        "accessModifier": "public",
        "signature": "public removeEndSlash(url: string): string",
        "isStatic": true,
        "isOptional": false,
        "descr": "Removes any slash characters from the end of the URL. \nThis function assumes that the input is already a valid absolute or server-relative URL. \nExamples: \nremoveEndSlash('http: \nremoveEndSlash('/example') ---> '/example' \nremoveEndSlash('/') ---> ''",
        "genericType": null,
        "returnType": "string",
        "returnDescr": null,
        "params": [
          {
            "name": "url",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  },
  "Validate": {
    "implementsExtendsName": null,
    "genericType": null,
    "descr": "This class implements provides a standard way to validate properties and function parameters. \nUnlike an assertion, the Validate checks are always performed and will always throw an error, \neven in a production release. As such, be careful not to overuse these checks in a way \nthat might impact performance.",
    "properties": {},
    "methods": {
      "isNonemptyString~95764": {
        "accessModifier": "public",
        "signature": "public isNonemptyString(value: string,variableName: string): void",
        "isStatic": true,
        "isOptional": false,
        "descr": "Throws an exception if the specified string is null,undefined,or an empty string.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "value",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "variableName",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "isNotNullOrUndefined~70703": {
        "accessModifier": "public",
        "signature": "public isNotNullOrUndefined(value: any,variableName: string): void",
        "isStatic": true,
        "isOptional": false,
        "descr": "Throws an exception if the specified value is null or undefined.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "value",
            "dataType": "any",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "variableName",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      },
      "isTrue~46018": {
        "accessModifier": "public",
        "signature": "public isTrue(value: boolean,variableName: string): void",
        "isStatic": true,
        "isOptional": false,
        "descr": "Throws an exception if the specified value is not true.",
        "genericType": null,
        "returnType": "void",
        "returnDescr": null,
        "params": [
          {
            "name": "value",
            "dataType": "boolean",
            "descr": "",
            "isOptional": false
          },
          {
            "name": "variableName",
            "dataType": "string",
            "descr": "",
            "isOptional": false
          }
        ]
      }
    },
    "functions": {}
  }
}