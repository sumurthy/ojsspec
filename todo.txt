1. Use TypeScript AST to generate the intermediary JSONs.
3. Modules are not supported. Need recursive way to support them.
4. HANDLE OBJECT TYPE OF DATA: (similar to module/object data type support)
  interface IHtmlProperties {
    imageLinkProperties: {
      [ propName: string ]: string
    }
    linkProperties: {
      [ propName: string ]: string
    }
    searchableProperties: {
      [ propName: string ]: string
    }
  }
5. Multi-line properties:
    properties: ICheckboxProps | ITextFieldProps | IToggleProps | IDropdownProps |
    ICustomPropertyPaneFieldProps | ILabelProps | ISliderProps | IChoiceGroupProps |
    IButtonProps | ILinkProps | any;
    (Do this outside as a first step of file processing)
6. properties/methods/functions: [{},{},{}] or {{}, {}, {}} ?
7. extends beyond 1 line
*/
interface IClientSideWebPartManifestInstance<TProperties> extends
 IClientSideComponentManifest,
 IClientSideWebPartManifestSharedProperties,
 IClientSideWebPartManifestEntry<TProperties> {
 /**
8. Property has {}
10. Type - has to check across multiple files
11. handle this:
declare enum RequestContext {
	"audio", "beacon", "cspreport", "download", "embed", "eventsource", "favicon", "fetch",
	"font", "form", "frame", "hyperlink", "iframe", "image", "imageset", "import",
	"internal", "location", "manifest", "object", "ping", "plugin", "prefetch", "script",
	"serviceworker", "sharedworker", "subresource", "style", "track", "video", "worker",
	"xmlhttprequest", "xslt"
}
12.
